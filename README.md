# deadlock
很多的时候我们会有这样的sql 查询，查询表里面的数据，然后判断这个数据是不是存在如果不存在就插入一条数据，如果在事物中，并发的情况下就会很容易出现死锁。 
例如：
table ： user
id   name  tel (索引) 
begin：
select * from user where tel = '123123' for update;
如果为空
insert into user .......
commit ;

在一些情况下就会出现死锁 首先看下测试数据库的隔离级别：
 是RR 的级别
目前表里面已有数据：
 
 id  name tel
 1   张三  15030220370
 2   李四  15030220379
这个时候 如果有一个 手机号为 15030220371 的请求 和 一个手机号为 15030220372 的数据都来请求 那么会发生什么  我们测试下
 

假设他们是并发执行的

这个时候死锁就出现了，那这是为啥呢？ 这时候我们看下 session2 insert 执行 前时候的锁占用情况

session 1 和 session 2 都会有GAP（间隙锁） 锁住 15030220370 - 15030220379 这个区间 但是
session 1 的GAP锁 和 session 2 的GAP 锁是共有的 也就是他们不是互斥的，但是这个时候我们又要
执行insert操作，再rr隔离级别下 插入的时候会有一个锁叫做插入意向锁 ，插入意向锁和 我们上面
select 的 gap 锁是 互斥的 因为我们两个session 插入的都在同一个区间，也就是 session2 插入要等待
session 1 插入  session 1 插入又要等session 2 释放gap 锁 这个时候死锁就产生了。
那么怎么解决这个问题呢？
出现问题的就是这个gap 锁，那么我们怎么把这个锁变成行锁呢 尝试了一些方式 发现没办法
只是可以把session隔离级别调整为  READ COMMITTED 这样不会有间隙锁 只会有行锁 这样可以解决这个问题。
